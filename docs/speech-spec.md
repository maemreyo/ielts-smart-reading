Ch√†o b·∫°n\! ƒê√¢y l√† m·ªôt danh s√°ch y√™u c·∫ßu tuy·ªát v·ªùi v√† r·∫•t r√µ r√†ng. Vi·ªác x√¢y d·ª±ng m·ªôt custom hook `useSpeech` (common) ƒë·ªÉ qu·∫£n l√Ω √¢m thanh l√† m·ªôt ki·∫øn tr√∫c r·∫•t chu·∫©n v√† th√¥ng minh trong React/Next.js.

Ch√∫ng ta s·∫Ω t·∫°o m·ªôt custom hook ƒë·ªÉ ƒë√≥ng g√≥i *to√†n b·ªô* logic b·∫°n y√™u c·∫ßu, gi√∫p cho c√°c component UI (n√∫t b·∫•m, slider) c·ªßa b·∫°n tr·ªü n√™n r·∫•t "ngu ng·ªëc" (dumb components) - ch√∫ng ch·ªâ vi·ªác g·ªçi h√†m v√† hi·ªÉn th·ªã state t·ª´ hook.

Tuy nhi√™n, tr∆∞·ªõc khi ƒëi v√†o code, c√≥ m·ªôt s·ªë **ƒëi·ªÅu ki·ªán v√† gi·ªõi h·∫°n r·∫•t quan tr·ªçng** b·∫°n c·∫ßn bi·∫øt khi s·ª≠tr√¨nh duy·ªát (`Web Speech API`):

> ‚ö†Ô∏è **Nh·ªØng gi·ªõi h·∫°n B·∫ÆT BU·ªòC ph·∫£i bi·∫øt c·ªßa API mi·ªÖn ph√≠**
>
> 1.  **V·ªÅ gi·ªçng ƒë·ªçc (Features 1, 2, 5):** S·ªë l∆∞·ª£ng v√† ch·∫•t l∆∞·ª£ng gi·ªçng ƒë·ªçc (Anh, Vi·ªát, hay b·∫•t k·ª≥ ng√¥n ng·ªØ n√†o) **ph·ª• thu·ªôc 100% v√†o tr√¨nh duy·ªát v√† h·ªá ƒëi·ªÅu h√†nh c·ªßa ng∆∞·ªùi d√πng**. B·∫°n *kh√¥ng th·ªÉ* ƒë·∫£m b·∫£o 100% ng∆∞·ªùi d√πng s·∫Ω c√≥ gi·ªçng `vi-VN` hay `en-GB`. V√≠ d·ª•, Chrome tr√™n Windows th∆∞·ªùng c√≥ gi·ªçng `Google Ti·∫øng Vi·ªát` v√† nhi·ªÅu gi·ªçng Anh, nh∆∞ng Firefox c√≥ th·ªÉ kh√¥ng.
> 2.  **V·ªÅ "Tua" (Feature 6):** API n√†y **kh√¥ng h·ªó tr·ª£ tua (seek)** nh∆∞ m·ªôt file MP3 (v√≠ d·ª•: tua ƒë·∫øn 0:30s). "Tua" ·ªü ƒë√¢y ƒë∆∞·ª£c hi·ªÉu l√† **"D·ª´ng v√† Ph√°t l·∫°i t·ª´ ƒë·∫ßu" (Stop/Rewind to start)**. H√†m `stop()` (t·ª©c l√† `speechSynthesis.cancel()`) s·∫Ω l√†m vi·ªác n√†y.
> 3.  **V·ªÅ vƒÉn b·∫£n d√†i (Feature 3):** H·∫ßu h·∫øt c√°c tr√¨nh duy·ªát c√≥ gi·ªõi h·∫°n k√Ω t·ª± (kho·∫£ng 32,000). N·∫øu vƒÉn b·∫£n qu√° d√†i, vi·ªác ƒë·ªçc c√≥ th·ªÉ b·ªã ng·∫Øt. Ch√∫ng ta c√≥ th·ªÉ x·ª≠ l√Ω vi·ªác n√†y, nh∆∞ng n√≥ s·∫Ω ph·ª©c t·∫°p h∆°n (v√≠ d·ª•: t·ª± ng·∫Øt c√¢u v√† ƒë∆∞a v√†o h√†ng ƒë·ª£i).

V·ªõi nh·ªØng hi·ªÉu bi·∫øt ƒë√≥, ch√∫ng ta h√£y x√¢y d·ª±ng hook `useSpeech` m·∫°nh m·∫Ω n√†y.

-----

### 1\. üèóÔ∏è M√£ ngu·ªìn Custom Hook: `hooks/useSpeech.ts`

ƒê√¢y l√† tr√°i tim c·ªßa h·ªá th·ªëng. H√£y t·∫°o file `hooks/useSpeech.ts` (ho·∫∑c `.js`).

```typescript
// B·∫Øt bu·ªôc ph·∫£i c√≥ "use client" v√¨ hook n√†y d√πng API c·ªßa tr√¨nh duy·ªát
"use client";

import { useState, useEffect, useRef, useCallback } from 'react';

// ƒê·ªãnh nghƒ©a c√°c t√πy ch·ªçn khi g·ªçi h√†m speak
export interface SpeakOptions {
  text: string;
  voice?: SpeechSynthesisVoice; // Gi·ªçng ƒë·ªçc c·ª• th·ªÉ
  rate?: number;                 // T·ªëc ƒë·ªô c·ª• th·ªÉ
  lang?: string;                 // Ng√¥n ng·ªØ (v√≠ d·ª• 'vi-VN' ho·∫∑c 'en-GB')
}

// ƒê√¢y l√† nh·ªØng g√¨ hook s·∫Ω tr·∫£ v·ªÅ cho component
export interface UseSpeechReturn {
  // Tr·∫°ng th√°i
  isSpeaking: boolean;
  isPaused: boolean;
  
  // Danh s√°ch gi·ªçng ƒë·ªçc
  voices: SpeechSynthesisVoice[];
  
  // H√†m ƒëi·ªÅu khi·ªÉn
  speak: (options: SpeakOptions) => void;
  pause: () => void;
  resume: () => void;
  stop: () => void; // D·ª´ng v√† x√≥a h√†ng ƒë·ª£i (Tua v·ªÅ ƒë·∫ßu)
  
  // C√†i ƒë·∫∑t chung
  setRate: (rate: number) => void;
  currentRate: number;
  setGlobalVoice: (voice: SpeechSynthesisVoice) => void;
  currentGlobalVoice: SpeechSynthesisVoice | null;
  
  // T√≠nh nƒÉng th√™m
  setSleepTimer: (minutes: number) => void; // H·∫πn gi·ªù t·∫Øt
}

// L·∫•y ƒë·ªëi t∆∞·ª£ng synth m·ªôt c√°ch an to√†n
const getSynth = (): SpeechSynthesis | null => {
  return typeof window !== 'undefined' ? window.speechSynthesis : null;
};


export const useSpeech = (defaultRate = 1): UseSpeechReturn => {
  const synth = getSynth();
  
  // State qu·∫£n l√Ω tr·∫°ng th√°i
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  
  // State qu·∫£n l√Ω c√†i ƒë·∫∑t
  const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);
  const [currentRate, setRate] = useState(defaultRate);
  const [currentGlobalVoice, setGlobalVoice] = useState<SpeechSynthesisVoice | null>(null);

  // Ref cho b·ªô h·∫πn gi·ªù
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  // --- 1. T·∫£i danh s√°ch gi·ªçng ƒë·ªçc ---
  const loadVoices = useCallback(() => {
    if (!synth) return;
    const availableVoices = synth.getVoices();
    setVoices(availableVoices);
    
    // T·ª± ƒë·ªông ch·ªçn 1 gi·ªçng m·∫∑c ƒë·ªãnh (v√≠ d·ª•: en-US)
    if (!currentGlobalVoice) {
      const defaultVoice = availableVoices.find(v => v.lang === 'en-US') || availableVoices[0];
      setGlobalVoice(defaultVoice || null);
    }
  }, [synth, currentGlobalVoice]);

  useEffect(() => {
    if (!synth) return;
    
    loadVoices(); // T·∫£i ngay l·∫≠p t·ª©c
    // S·ª± ki·ªán 'voiceschanged' l√† b·∫Øt bu·ªôc
    synth.addEventListener('voiceschanged', loadVoices);

    return () => {
      synth.removeEventListener('voiceschanged', loadVoices);
    };
  }, [synth, loadVoices]);

  // --- 2. H√†m ƒëi·ªÅu khi·ªÉn ch√≠nh ---
  
  const stop = useCallback(() => {
    if (!synth) return;
    synth.cancel(); // X√≥a h√†ng ƒë·ª£i v√† d·ª´ng ngay l·∫≠p t·ª©c
    setIsSpeaking(false);
    setIsPaused(false);
    // C≈©ng x√≥a lu√¥n h·∫πn gi·ªù t·∫Øt
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  }, [synth]);

  // H√†m speak s·∫Ω t·∫°o v√† ƒë∆∞a v√†o H√ÄNG ƒê·ª¢I
  const speak = useCallback((options: SpeakOptions) => {
    if (!synth) return;
    
    // N·∫øu ƒëang t·∫°m d·ª´ng, nh·∫•n play s·∫Ω ti·∫øp t·ª•c thay v√¨ n√≥i c√¢u m·ªõi
    if (isPaused) {
      resume();
      return;
    }
    
    const { text, voice, rate, lang } = options;
    
    const utterance = new SpeechSynthesisUtterance(text);
    
    // ∆Øu ti√™n 1: Gi·ªçng ƒë·ªçc ƒë∆∞·ª£c truy·ªÅn v√†o (options.voice)
    // ∆Øu ti√™n 2: Gi·ªçng ƒë·ªçc chung ƒë√£ c√†i (currentGlobalVoice)
    // ∆Øu ti√™n 3: T√¨m gi·ªçng theo ng√¥n ng·ªØ (options.lang)
    // ∆Øu ti√™n 4: M·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát
    if (voice) {
      utterance.voice = voice;
    } else if (currentGlobalVoice) {
      utterance.voice = currentGlobalVoice;
    } else if (lang) {
      const voiceForLang = voices.find(v => v.lang.startsWith(lang));
      if (voiceForLang) utterance.voice = voiceForLang;
    }
    
    utterance.rate = rate || currentRate;

    // C·∫≠p nh·∫≠t state khi b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c
    utterance.onstart = () => {
      setIsSpeaking(true);
      setIsPaused(false);
    };

    utterance.onend = () => {
      // Ch·ªâ set false n·∫øu h√†ng ƒë·ª£i tr·ªëng
      if (!synth.pending) {
        setIsSpeaking(false);
        setIsPaused(false);
      }
    };
    
    utterance.onerror = (e) => {
      console.error("SpeechSynthesis Error:", e);
      setIsSpeaking(false);
      setIsPaused(false);
    };

    synth.speak(utterance);
    
  }, [synth, currentRate, currentGlobalVoice, voices, isPaused]);

  const pause = useCallback(() => {
    if (!synth || !isSpeaking) return;
    synth.pause();
    setIsPaused(true);
    setIsSpeaking(false);
  }, [synth, isSpeaking]);

  const resume = useCallback(() => {
    if (!synth || !isPaused) return;
    synth.resume();
    setIsPaused(false);
    setIsSpeaking(true);
  }, [synth, isPaused]);

  // --- 3. T√≠nh nƒÉng th√™m: H·∫πn gi·ªù t·∫Øt ---
  const setSleepTimer = useCallback((minutes: number) => {
    // H·ªßy timer c≈© n·∫øu c√≥
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
    
    // N·∫øu minutes = 0, t·ª©c l√† t·∫Øt h·∫πn gi·ªù
    if (minutes > 0) {
      const ms = minutes * 60 * 1000;
      console.log(`Setting sleep timer for ${minutes} minutes.`);
      timerRef.current = setTimeout(() => {
        console.log('Sleep timer triggered. Stopping speech.');
        stop();
      }, ms);
    } else {
      console.log('Sleep timer cancelled.');
    }
  }, [stop]);

  // --- 4. T√≠nh nƒÉng th√™m: Hotkeys (Ph√≠m t·∫Øt) ---
  // Ch√∫ng ta k√≠ch ho·∫°t n√≥ b√™n trong component thay v√¨ trong hook
  // Nh∆∞ng hook c√≥ th·ªÉ cung c·∫•p c√°c h√†m ƒë·ªÉ component g·ªçi
  
  // Tr·∫£ v·ªÅ m·ªçi th·ª© component c·∫ßn
  return {
    isSpeaking,
    isPaused,
    voices,
    speak,
    pause,
    resume,
    stop,
    setRate,
    currentRate,
    setGlobalVoice,
    currentGlobalVoice,
    setSleepTimer,
  };
};
```

-----

### 2\. üñ•Ô∏è C√°ch s·ª≠ d·ª•ng Hook trong Component

B√¢y gi·ªù, component c·ªßa b·∫°n (v√≠ d·ª• `components/MyEnglishLesson.tsx`) s·∫Ω tr·ªü n√™n r·∫•t g·ªçn g√†ng.

```typescript
// B·∫Øt bu·ªôc ph·∫£i c√≥ "use client"
"use client";

import React, { useState, useEffect, useMemo } from 'react';
import { useSpeech, SpeakOptions } from '@/hooks/useSpeech';

const MyEnglishLesson: React.FC = () => {
  // Ch·ªâ c·∫ßn g·ªçi hook
  const {
    isSpeaking,
    isPaused,
    voices,
    speak,
    pause,
    resume,
    stop,
    setRate,
    currentRate,
    setGlobalVoice,
    currentGlobalVoice,
    setSleepTimer,
  } = useSpeech(1.0); // T·ªëc ƒë·ªô m·∫∑c ƒë·ªãnh l√† 1.0

  // State ri√™ng c·ªßa component
  const [textToRead, setTextToRead] = useState(
    "Hello world. This is a long paragraph for testing the speech synthesis API in a Next.js application."
  );
  
  // L·ªçc danh s√°ch gi·ªçng ƒë·ªçc Anh/Vi·ªát
  const englishVoices = useMemo(() => voices.filter(v => v.lang.startsWith('en')), [voices]);
  const vietnameseVoices = useMemo(() => voices.filter(v => v.lang.startsWith('vi')), [voices]);

  // --- X·ª≠ l√Ω Ph√≠m t·∫Øt (Feature 9) ---
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // V√≠ d·ª•: Ctrl + Space ƒë·ªÉ Play/Pause
      if (event.ctrlKey && event.code === 'Space') {
        event.preventDefault();
        if (isSpeaking) {
          pause();
        } else {
          // N·∫øu ƒëang t·∫°m d·ª´ng th√¨ resume, n·∫øu kh√¥ng th√¨ speak
          if (isPaused) {
            resume();
          } else {
            speak({ text: textToRead });
          }
        }
      }
      
      // V√≠ d·ª•: Ctrl + S ƒë·ªÉ Stop
      if (event.ctrlKey && event.code === 'KeyS') {
        event.preventDefault();
        stop();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isSpeaking, isPaused, textToRead, speak, pause, resume, stop]);


  // --- Render UI ---
  return (
    <div style={{ fontFamily: 'sans-serif', padding: '20px' }}>
      <h3>B√†i ƒë·ªçc</h3>
      <textarea
        value={textToRead}
        onChange={(e) => setTextToRead(e.target.value)}
        rows={5}
        style={{ width: '100%' }}
      />
      
      {/* 1. ƒêi·ªÅu khi·ªÉn ch√≠nh */}
      <h4>ƒêi·ªÅu khi·ªÉn (Ctrl+Space, Ctrl+S)</h4>
      <button onClick={() => speak({ text: textToRead })}>
        {isPaused ? 'Ti·∫øp t·ª•c' : 'Ph√°t'}
      </button>
      <button onClick={pause} disabled={!isSpeaking}>T·∫°m d·ª´ng</button>
      <button onClick={resume} disabled={!isPaused}>Ti·∫øp t·ª•c</button>
      <button onClick={stop}>D·ª´ng (Tua l·∫°i)</button>

      {/* 2. C√†i ƒë·∫∑t chung */}
      <h4>C√†i ƒë·∫∑t</h4>
      <div>
        <label>T·ªëc ƒë·ªô: {currentRate.toFixed(1)}x</label>
        <input
          type="range"
          min="0.5"
          max="2"
          step="0.1"
          value={currentRate}
          onChange={(e) => setRate(parseFloat(e.target.value))}
        />
      </div>

      <div>
        <label>Gi·ªçng ƒë·ªçc chung: </label>
        <select
          value={currentGlobalVoice?.name || ''}
          onChange={(e) => {
            const voice = voices.find(v => v.name === e.target.value);
            setGlobalVoice(voice || null);
          }}
        >
          <option value="">-- T·ª± ƒë·ªông --</option>
          {voices.map(v => (
            <option key={v.name} value={v.name}>{v.name} ({v.lang})</option>
          ))}
        </select>
      </div>
      
      <div>
        <label>H·∫πn gi·ªù t·∫Øt (ph√∫t, 0 = t·∫Øt): </label>
        <input 
          type="number" 
          min="0"
          defaultValue="0"
          onChange={(e) => setSleepTimer(parseInt(e.target.value, 10) || 0)}
        />
      </div>
      
      {/* 3. ƒê·ªçc c√°c c√¢u/t·ª´ ri√™ng l·∫ª */}
      <h4>ƒê·ªçc c√°c ph·∫ßn ri√™ng (Feature 4)</h4>
      <p>
        H·ªçc t·ª´: <button onClick={() => speak({ text: "Apple", lang: 'en' })}>Apple</button>
      </p>
      <p>
        Gi·∫£i th√≠ch: <button onClick={() => speak({ text: "Qu·∫£ t√°o", lang: 'vi' })}>Qu·∫£ t√°o</button>
      </p>
      <p>
        V√≠ d·ª•: <button onClick={() => speak({ text: "I want to eat an apple.", lang: 'en' })}>I want to eat an apple.</button>
      </p>
      
      {/* 4. Ch·ªçn gi·ªçng Anh/Vi·ªát (Feature 1, 2) */}
      <p>
        Ph√°t √¢m "Hello" gi·ªçng Anh (UK):
        <select onChange={(e) => {
          const voice = voices.find(v => v.name === e.target.value);
          if (voice) speak({ text: "Hello", voice: voice });
        }}>
          {englishVoices.length === 0 ? <option>Kh√¥ng c√≥ gi·ªçng Anh</option> :
            englishVoices.map(v => <option key={v.name} value={v.name}>{v.name}</option>)
          }
        </select>
      </p>
      
    </div>
  );
};

export default MyEnglishLesson;
```

-----

### 3\. üí° T√≠nh nƒÉng ƒë·ªÅ xu·∫•t (Feature 10)

Ki·∫øn tr√∫c hook n√†y m·ªü ra 2 t√≠nh nƒÉng c·ª±c k·ª≥ m·∫°nh m·∫Ω:

1.  **H√†ng ƒë·ª£i ph√°t √¢m (Automatic Queuing):**

      * B·∫°n c√≥ th·∫•y trong v√≠ d·ª• "ƒê·ªçc c√°c ph·∫ßn ri√™ng" (Feature 4) kh√¥ng? N·∫øu b·∫°n b·∫•m "Apple", r·ªìi "Qu·∫£ t√°o", r·ªìi "I want to eat an apple" th·∫≠t nhanh, API s·∫Ω **t·ª± ƒë·ªông x·∫øp h√†ng** (queue) ch√∫ng v√† ƒë·ªçc l·∫ßn l∆∞·ª£t.
      * ƒê√¢y ch√≠nh l√† l√Ω do h√†m `speak` c·ªßa ch√∫ng ta kh√¥ng g·ªçi `stop()` (t·ª©c l√† `cancel()`). N√≥ cho ph√©p b·∫°n x√¢y d·ª±ng m·ªôt chu·ªói ƒë·ªçc (v√≠ d·ª•: ƒë·ªçc t·ª´, d·ª´ng 1s, ƒë·ªçc nghƒ©a, d·ª´ng 1s, ƒë·ªçc v√≠ d·ª•) r·∫•t m∆∞·ª£t m√†.

2.  **ƒê√°nh d·∫•u t·ª´ ƒëang ƒë·ªçc (Text Highlighting):**

      * ƒê√¢y l√† t√≠nh nƒÉng *gi·∫øt ch·∫øt* (killer feature) cho app h·ªçc ti·∫øng Anh.
      * `SpeechSynthesisUtterance` c√≥ m·ªôt s·ª± ki·ªán l√† `onboundary`. S·ª± ki·ªán n√†y k√≠ch ho·∫°t khi tr√¨nh duy·ªát ƒë·ªçc ƒë·∫øn m·ªôt t·ª´ (ho·∫∑c c√¢u) m·ªõi.
      * B·∫°n c√≥ th·ªÉ d√πng n√≥ ƒë·ªÉ l·∫•y `event.charIndex` (v·ªã tr√≠ k√Ω t·ª±) v√† c·∫≠p nh·∫≠t UI, t√¥ v√†ng t·ª´ ƒëang ƒë∆∞·ª£c ƒë·ªçc.
      * **C√°ch l√†m:** M·ªü r·ªông hook `useSpeech` ƒë·ªÉ nh·∫≠n th√™m m·ªôt callback `onBoundary` v√† tr·∫£ v·ªÅ `currentCharIndex`. Component UI s·∫Ω nh·∫≠n index n√†y v√† t√¥ m√†u ph·∫ßn vƒÉn b·∫£n t∆∞∆°ng ·ª©ng.

-----

### 4\. T·ªïng k·∫øt (Checklist c√°c y√™u c·∫ßu)

H√£y xem hook n√†y ƒë√£ gi·∫£i quy·∫øt c√°c y√™u c·∫ßu c·ªßa b·∫°n th·∫ø n√†o:

| Y√™u c·∫ßu | Gi·∫£i ph√°p trong Hook |
| :--- | :--- |
| 1. Gi·ªçng Anh | L·ªçc `voices` theo `en` (v√≠ d·ª• `en-GB`, `en-US`). *Gi·ªõi h·∫°n: Ph·ª• thu·ªôc tr√¨nh duy·ªát.* |
| 2. Gi·ªçng Vi·ªát | L·ªçc `voices` theo `vi` (v√≠ d·ª• `vi-VN`). *Gi·ªõi h·∫°n: Ph·ª• thu·ªôc tr√¨nh duy·ªát.* |
| 3. ƒê·ªçc b√†i d√†i | `speak({ text: longText })`. *Gi·ªõi h·∫°n: Gi·ªõi h·∫°n k√Ω t·ª± c·ªßa tr√¨nh duy·ªát.* |
| 4. ƒê·ªçc c√¢u/t·ª´ | `speak({ text: word, lang: 'en' })`. T√≠nh nƒÉng x·∫øp h√†ng (queue) r·∫•t h·ªØu √≠ch ·ªü ƒë√¢y. |
| 5. Nhi·ªÅu gi·ªçng | State `voices` v√† h√†m `setGlobalVoice` ho·∫∑c `options.voice` trong `speak()`. |
| 6. Tua | H√†m `stop()` (t·ª©c l√† `synth.cancel()`) s·∫Ω d·ª´ng v√† x√≥a h√†ng ƒë·ª£i. L·∫ßn `speak()` ti·∫øp theo s·∫Ω b·∫Øt ƒë·∫ßu l·∫°i. |
| 7. ƒêi·ªÅu khi·ªÉn t·ªëc ƒë·ªô | State `currentRate` v√† h√†m `setRate()`. |
| 8. H·∫πn gi·ªù t·∫Øt | H√†m `setSleepTimer()` s·ª≠ d·ª•ng `useRef` v√† `setTimeout`. |
| 9. Hotkey | `useEffect` trong *Component* (v√≠ d·ª•) ƒë·ªÉ l·∫Øng nghe `keydown` v√† g·ªçi c√°c h√†m ( `pause`, `stop`...) t·ª´ hook. |
| 10. T√≠nh nƒÉng x·ªãn | **Text Highlighting** (d√πng `onboundary`) v√† **Queuing** (ƒë√£ t√≠ch h·ª£p s·∫µn). |

ƒê√¢y l√† m·ªôt n·ªÅn t·∫£ng r·∫•t v·ªØng ch·∫Øc. B·∫°n c√≥ mu·ªën t√¥i tri·ªÉn khai th·ª≠ t√≠nh nƒÉng s·ªë 10 (Text Highlighting) v√†o hook `useSpeech` kh√¥ng? N√≥ s·∫Ω l√†m hook ph·ª©c t·∫°p h∆°n m·ªôt ch√∫t nh∆∞ng r·∫•t ƒë√°ng gi√°.

